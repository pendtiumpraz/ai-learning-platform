import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeDateTime as __serializeDateTime, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { CloudWatchServiceException as __BaseException } from "../models/CloudWatchServiceException";
import { ConcurrentModificationException, ConflictException, DashboardInvalidInputError, InternalServiceFault, InvalidFormatFault, InvalidNextToken, InvalidParameterCombinationException, InvalidParameterValueException, LimitExceededException, LimitExceededFault, MissingRequiredParameterException, ResourceNotFound, ResourceNotFoundException, } from "../models/models_0";
export const se_DeleteAlarmsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAlarmsInput(input, context),
        [_A]: _DA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAnomalyDetectorCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAnomalyDetectorInput(input, context),
        [_A]: _DAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDashboardsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDashboardsInput(input, context),
        [_A]: _DD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInsightRulesInput(input, context),
        [_A]: _DIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteMetricStreamInput(input, context),
        [_A]: _DMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAlarmContributorsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmContributorsInput(input, context),
        [_A]: _DAC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAlarmHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmHistoryInput(input, context),
        [_A]: _DAH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAlarmsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmsInput(input, context),
        [_A]: _DAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAlarmsForMetricCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmsForMetricInput(input, context),
        [_A]: _DAFM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAnomalyDetectorsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAnomalyDetectorsInput(input, context),
        [_A]: _DADe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInsightRulesInput(input, context),
        [_A]: _DIRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableAlarmActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableAlarmActionsInput(input, context),
        [_A]: _DAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableInsightRulesInput(input, context),
        [_A]: _DIRi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableAlarmActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableAlarmActionsInput(input, context),
        [_A]: _EAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableInsightRulesInput(input, context),
        [_A]: _EIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDashboardCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetDashboardInput(input, context),
        [_A]: _GD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInsightRuleReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInsightRuleReportInput(input, context),
        [_A]: _GIRR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricDataInput(input, context),
        [_A]: _GMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricStatisticsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricStatisticsInput(input, context),
        [_A]: _GMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricStreamInput(input, context),
        [_A]: _GMSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricWidgetImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricWidgetImageInput(input, context),
        [_A]: _GMWI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDashboardsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListDashboardsInput(input, context),
        [_A]: _LD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListManagedInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListManagedInsightRulesInput(input, context),
        [_A]: _LMIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListMetricsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMetricsInput(input, context),
        [_A]: _LM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMetricStreamsInput(input, context),
        [_A]: _LMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListTagsForResourceInput(input, context),
        [_A]: _LTFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutAnomalyDetectorCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutAnomalyDetectorInput(input, context),
        [_A]: _PAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutCompositeAlarmCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutCompositeAlarmInput(input, context),
        [_A]: _PCA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutDashboardCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutDashboardInput(input, context),
        [_A]: _PD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutInsightRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutInsightRuleInput(input, context),
        [_A]: _PIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutManagedInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutManagedInsightRulesInput(input, context),
        [_A]: _PMIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutMetricAlarmCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricAlarmInput(input, context),
        [_A]: _PMA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutMetricDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricDataInput(input, context),
        [_A]: _PMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricStreamInput(input, context),
        [_A]: _PMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetAlarmStateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetAlarmStateInput(input, context),
        [_A]: _SAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartMetricStreamsInput(input, context),
        [_A]: _SMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StopMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StopMetricStreamsInput(input, context),
        [_A]: _SMSt,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagResourceInput(input, context),
        [_A]: _TR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagResourceInput(input, context),
        [_A]: _UR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_DeleteAlarmsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteAnomalyDetectorCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteAnomalyDetectorOutput(data.DeleteAnomalyDetectorResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteDashboardsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDashboardsOutput(data.DeleteDashboardsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteInsightRulesOutput(data.DeleteInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteMetricStreamOutput(data.DeleteMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAlarmContributorsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmContributorsOutput(data.DescribeAlarmContributorsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAlarmHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmHistoryOutput(data.DescribeAlarmHistoryResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAlarmsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmsOutput(data.DescribeAlarmsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAlarmsForMetricCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmsForMetricOutput(data.DescribeAlarmsForMetricResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAnomalyDetectorsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAnomalyDetectorsOutput(data.DescribeAnomalyDetectorsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInsightRulesOutput(data.DescribeInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableAlarmActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DisableInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableInsightRulesOutput(data.DisableInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableAlarmActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_EnableInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableInsightRulesOutput(data.EnableInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetDashboardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDashboardOutput(data.GetDashboardResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetInsightRuleReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInsightRuleReportOutput(data.GetInsightRuleReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetMetricDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricDataOutput(data.GetMetricDataResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetMetricStatisticsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricStatisticsOutput(data.GetMetricStatisticsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricStreamOutput(data.GetMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetMetricWidgetImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricWidgetImageOutput(data.GetMetricWidgetImageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListDashboardsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDashboardsOutput(data.ListDashboardsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListManagedInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListManagedInsightRulesOutput(data.ListManagedInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListMetricsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMetricsOutput(data.ListMetricsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMetricStreamsOutput(data.ListMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListTagsForResourceOutput(data.ListTagsForResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutAnomalyDetectorCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutAnomalyDetectorOutput(data.PutAnomalyDetectorResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutCompositeAlarmCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_PutDashboardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutDashboardOutput(data.PutDashboardResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutInsightRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutInsightRuleOutput(data.PutInsightRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutManagedInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutManagedInsightRulesOutput(data.PutManagedInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutMetricAlarmCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_PutMetricDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_PutMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutMetricStreamOutput(data.PutMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetAlarmStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_StartMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartMetricStreamsOutput(data.StartMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StopMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StopMetricStreamsOutput(data.StopMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagResourceOutput(data.TagResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UntagResourceOutput(data.UntagResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#ResourceNotFound":
            throw await de_ResourceNotFoundRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.cloudwatch#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.cloudwatch#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "InvalidParameterInput":
        case "com.amazonaws.cloudwatch#DashboardInvalidInputError":
            throw await de_DashboardInvalidInputErrorRes(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.cloudwatch#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidFormat":
        case "com.amazonaws.cloudwatch#InvalidFormatFault":
            throw await de_InvalidFormatFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConcurrentModificationException(body.Error, context);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConflictException(body.Error, context);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DashboardInvalidInputErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DashboardInvalidInputError(body.Error, context);
    const exception = new DashboardInvalidInputError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalServiceFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InternalServiceFault(body.Error, context);
    const exception = new InternalServiceFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidFormatFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidFormatFault(body.Error, context);
    const exception = new InvalidFormatFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNextTokenRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNextToken(body.Error, context);
    const exception = new InvalidNextToken({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterCombinationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterCombinationException(body.Error, context);
    const exception = new InvalidParameterCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterValueException(body.Error, context);
    const exception = new InvalidParameterValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body.Error, context);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededFault(body.Error, context);
    const exception = new LimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MissingRequiredParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MissingRequiredParameterException(body.Error, context);
    const exception = new MissingRequiredParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFound(body.Error, context);
    const exception = new ResourceNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundException(body.Error, context);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AlarmNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AlarmTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AnomalyDetectorConfiguration = (input, context) => {
    const entries = {};
    if (input[_ETR] != null) {
        const memberEntries = se_AnomalyDetectorExcludedTimeRanges(input[_ETR], context);
        if (input[_ETR]?.length === 0) {
            entries.ExcludedTimeRanges = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludedTimeRanges.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MT] != null) {
        entries[_MT] = input[_MT];
    }
    return entries;
};
const se_AnomalyDetectorExcludedTimeRanges = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Range(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AnomalyDetectorTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Counts = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = __serializeFloat(entry);
        counter++;
    }
    return entries;
};
const se_DashboardNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DeleteAlarmsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteAnomalyDetectorInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_SMAD] != null) {
        const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SingleMetricAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MMAD] != null) {
        const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricMathAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteDashboardsInput = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        const memberEntries = se_DashboardNames(input[_DN], context);
        if (input[_DN]?.length === 0) {
            entries.DashboardNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DashboardNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        const memberEntries = se_InsightRuleNames(input[_RN], context);
        if (input[_RN]?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteMetricStreamInput = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    return entries;
};
const se_DescribeAlarmContributorsInput = (input, context) => {
    const entries = {};
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeAlarmHistoryInput = (input, context) => {
    const entries = {};
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_ACI] != null) {
        entries[_ACI] = input[_ACI];
    }
    if (input[_AT] != null) {
        const memberEntries = se_AlarmTypes(input[_AT], context);
        if (input[_AT]?.length === 0) {
            entries.AlarmTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HIT] != null) {
        entries[_HIT] = input[_HIT];
    }
    if (input[_SD] != null) {
        entries[_SD] = __serializeDateTime(input[_SD]);
    }
    if (input[_ED] != null) {
        entries[_ED] = __serializeDateTime(input[_ED]);
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    return entries;
};
const se_DescribeAlarmsForMetricInput = (input, context) => {
    const entries = {};
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_ES] != null) {
        entries[_ES] = input[_ES];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_DescribeAlarmsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ANP] != null) {
        entries[_ANP] = input[_ANP];
    }
    if (input[_AT] != null) {
        const memberEntries = se_AlarmTypes(input[_AT], context);
        if (input[_AT]?.length === 0) {
            entries.AlarmTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_COAN] != null) {
        entries[_COAN] = input[_COAN];
    }
    if (input[_POAN] != null) {
        entries[_POAN] = input[_POAN];
    }
    if (input[_SV] != null) {
        entries[_SV] = input[_SV];
    }
    if (input[_AP] != null) {
        entries[_AP] = input[_AP];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeAnomalyDetectorsInput = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ADT] != null) {
        const memberEntries = se_AnomalyDetectorTypes(input[_ADT], context);
        if (input[_ADT]?.length === 0) {
            entries.AnomalyDetectorTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AnomalyDetectorTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    return entries;
};
const se_Dimension = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_DimensionFilter = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_DimensionFilters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_DimensionFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Dimensions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Dimension(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_DisableAlarmActionsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisableInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        const memberEntries = se_InsightRuleNames(input[_RN], context);
        if (input[_RN]?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnableAlarmActionsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnableInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        const memberEntries = se_InsightRuleNames(input[_RN], context);
        if (input[_RN]?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Entity = (input, context) => {
    const entries = {};
    if (input[_KA] != null) {
        const memberEntries = se_EntityKeyAttributesMap(input[_KA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `KeyAttributes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_At] != null) {
        const memberEntries = se_EntityAttributesMap(input[_At], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Attributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EntityAttributesMap = (input, context) => {
    const entries = {};
    let counter = 1;
    Object.keys(input)
        .filter((key) => input[key] != null)
        .forEach((key) => {
        entries[`entry.${counter}.key`] = key;
        entries[`entry.${counter}.value`] = input[key];
        counter++;
    });
    return entries;
};
const se_EntityKeyAttributesMap = (input, context) => {
    const entries = {};
    let counter = 1;
    Object.keys(input)
        .filter((key) => input[key] != null)
        .forEach((key) => {
        entries[`entry.${counter}.key`] = key;
        entries[`entry.${counter}.value`] = input[key];
        counter++;
    });
    return entries;
};
const se_EntityMetricData = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        const memberEntries = se_Entity(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Entity.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MD] != null) {
        const memberEntries = se_MetricData(input[_MD], context);
        if (input[_MD]?.length === 0) {
            entries.MetricData = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricData.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EntityMetricDataList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_EntityMetricData(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ExtendedStatistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GetDashboardInput = (input, context) => {
    const entries = {};
    if (input[_DNa] != null) {
        entries[_DNa] = input[_DNa];
    }
    return entries;
};
const se_GetInsightRuleReportInput = (input, context) => {
    const entries = {};
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_ST] != null) {
        entries[_ST] = __serializeDateTime(input[_ST]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_MCC] != null) {
        entries[_MCC] = input[_MCC];
    }
    if (input[_M] != null) {
        const memberEntries = se_InsightRuleMetricList(input[_M], context);
        if (input[_M]?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OB] != null) {
        entries[_OB] = input[_OB];
    }
    return entries;
};
const se_GetMetricDataInput = (input, context) => {
    const entries = {};
    if (input[_MDQ] != null) {
        const memberEntries = se_MetricDataQueries(input[_MDQ], context);
        if (input[_MDQ]?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ST] != null) {
        entries[_ST] = __serializeDateTime(input[_ST]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_MDa] != null) {
        entries[_MDa] = input[_MDa];
    }
    if (input[_LO] != null) {
        const memberEntries = se_LabelOptions(input[_LO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LabelOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetMetricStatisticsInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ST] != null) {
        entries[_ST] = __serializeDateTime(input[_ST]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Sta] != null) {
        const memberEntries = se_Statistics(input[_Sta], context);
        if (input[_Sta]?.length === 0) {
            entries.Statistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Statistics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ESx] != null) {
        const memberEntries = se_ExtendedStatistics(input[_ESx], context);
        if (input[_ESx]?.length === 0) {
            entries.ExtendedStatistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExtendedStatistics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_GetMetricStreamInput = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    return entries;
};
const se_GetMetricWidgetImageInput = (input, context) => {
    const entries = {};
    if (input[_MW] != null) {
        entries[_MW] = input[_MW];
    }
    if (input[_OF] != null) {
        entries[_OF] = input[_OF];
    }
    return entries;
};
const se_InsightRuleMetricList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InsightRuleNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LabelOptions = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    return entries;
};
const se_ListDashboardsInput = (input, context) => {
    const entries = {};
    if (input[_DNP] != null) {
        entries[_DNP] = input[_DNP];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_ListManagedInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    return entries;
};
const se_ListMetricsInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_DimensionFilters(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_ILA] != null) {
        entries[_ILA] = input[_ILA];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    return entries;
};
const se_ListMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    return entries;
};
const se_ListTagsForResourceInput = (input, context) => {
    const entries = {};
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    return entries;
};
const se_ManagedRule = (input, context) => {
    const entries = {};
    if (input[_TN] != null) {
        entries[_TN] = input[_TN];
    }
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ManagedRules = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ManagedRule(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Metric = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricCharacteristics = (input, context) => {
    const entries = {};
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_MetricData = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDatum(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQuery = (input, context) => {
    const entries = {};
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_MS] != null) {
        const memberEntries = se_MetricStat(input[_MS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricStat.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ex] != null) {
        entries[_Ex] = input[_Ex];
    }
    if (input[_L] != null) {
        entries[_L] = input[_L];
    }
    if (input[_RD] != null) {
        entries[_RD] = input[_RD];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    return entries;
};
const se_MetricDatum = (input, context) => {
    const entries = {};
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ti] != null) {
        entries[_Ti] = __serializeDateTime(input[_Ti]);
    }
    if (input[_Va] != null) {
        entries[_Va] = __serializeFloat(input[_Va]);
    }
    if (input[_SVt] != null) {
        const memberEntries = se_StatisticSet(input[_SVt], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StatisticValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Val] != null) {
        const memberEntries = se_Values(input[_Val], context);
        if (input[_Val]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_C] != null) {
        const memberEntries = se_Counts(input[_C], context);
        if (input[_C]?.length === 0) {
            entries.Counts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Counts.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_SR] != null) {
        entries[_SR] = input[_SR];
    }
    return entries;
};
const se_MetricMathAnomalyDetector = (input, context) => {
    const entries = {};
    if (input[_MDQ] != null) {
        const memberEntries = se_MetricDataQueries(input[_MDQ], context);
        if (input[_MDQ]?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStat = (input, context) => {
    const entries = {};
    if (input[_Me] != null) {
        const memberEntries = se_Metric(input[_Me], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metric.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_MetricStreamFilter = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MNe] != null) {
        const memberEntries = se_MetricStreamFilterMetricNames(input[_MNe], context);
        if (input[_MNe]?.length === 0) {
            entries.MetricNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStreamFilterMetricNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamFilters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsAdditionalStatistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsConfiguration = (input, context) => {
    const entries = {};
    if (input[_IM] != null) {
        const memberEntries = se_MetricStreamStatisticsIncludeMetrics(input[_IM], context);
        if (input[_IM]?.length === 0) {
            entries.IncludeMetrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IncludeMetrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AS] != null) {
        const memberEntries = se_MetricStreamStatisticsAdditionalStatistics(input[_AS], context);
        if (input[_AS]?.length === 0) {
            entries.AdditionalStatistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AdditionalStatistics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStreamStatisticsConfigurations = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamStatisticsConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsIncludeMetrics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamStatisticsMetric(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsMetric = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    return entries;
};
const se_PutAnomalyDetectorInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_Co] != null) {
        const memberEntries = se_AnomalyDetectorConfiguration(input[_Co], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Configuration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MC] != null) {
        const memberEntries = se_MetricCharacteristics(input[_MC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricCharacteristics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SMAD] != null) {
        const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SingleMetricAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MMAD] != null) {
        const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricMathAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutCompositeAlarmInput = (input, context) => {
    const entries = {};
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_AA] != null) {
        const memberEntries = se_ResourceList(input[_AA], context);
        if (input[_AA]?.length === 0) {
            entries.AlarmActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AD] != null) {
        entries[_AD] = input[_AD];
    }
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_AR] != null) {
        entries[_AR] = input[_AR];
    }
    if (input[_IDA] != null) {
        const memberEntries = se_ResourceList(input[_IDA], context);
        if (input[_IDA]?.length === 0) {
            entries.InsufficientDataActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InsufficientDataActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OKA] != null) {
        const memberEntries = se_ResourceList(input[_OKA], context);
        if (input[_OKA]?.length === 0) {
            entries.OKActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OKActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASc] != null) {
        entries[_ASc] = input[_ASc];
    }
    if (input[_ASWP] != null) {
        entries[_ASWP] = input[_ASWP];
    }
    if (input[_ASEP] != null) {
        entries[_ASEP] = input[_ASEP];
    }
    return entries;
};
const se_PutDashboardInput = (input, context) => {
    const entries = {};
    if (input[_DNa] != null) {
        entries[_DNa] = input[_DNa];
    }
    if (input[_DB] != null) {
        entries[_DB] = input[_DB];
    }
    return entries;
};
const se_PutInsightRuleInput = (input, context) => {
    const entries = {};
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_RS] != null) {
        entries[_RS] = input[_RS];
    }
    if (input[_RDu] != null) {
        entries[_RDu] = input[_RDu];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AOTL] != null) {
        entries[_AOTL] = input[_AOTL];
    }
    return entries;
};
const se_PutManagedInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_MRan] != null) {
        const memberEntries = se_ManagedRules(input[_MRan], context);
        if (input[_MRan]?.length === 0) {
            entries.ManagedRules = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ManagedRules.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutMetricAlarmInput = (input, context) => {
    const entries = {};
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_AD] != null) {
        entries[_AD] = input[_AD];
    }
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_OKA] != null) {
        const memberEntries = se_ResourceList(input[_OKA], context);
        if (input[_OKA]?.length === 0) {
            entries.OKActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OKActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AA] != null) {
        const memberEntries = se_ResourceList(input[_AA], context);
        if (input[_AA]?.length === 0) {
            entries.AlarmActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IDA] != null) {
        const memberEntries = se_ResourceList(input[_IDA], context);
        if (input[_IDA]?.length === 0) {
            entries.InsufficientDataActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InsufficientDataActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_ES] != null) {
        entries[_ES] = input[_ES];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_EP] != null) {
        entries[_EP] = input[_EP];
    }
    if (input[_DTA] != null) {
        entries[_DTA] = input[_DTA];
    }
    if (input[_Th] != null) {
        entries[_Th] = __serializeFloat(input[_Th]);
    }
    if (input[_CO] != null) {
        entries[_CO] = input[_CO];
    }
    if (input[_TMD] != null) {
        entries[_TMD] = input[_TMD];
    }
    if (input[_ELSCP] != null) {
        entries[_ELSCP] = input[_ELSCP];
    }
    if (input[_M] != null) {
        const memberEntries = se_MetricDataQueries(input[_M], context);
        if (input[_M]?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TMI] != null) {
        entries[_TMI] = input[_TMI];
    }
    return entries;
};
const se_PutMetricDataInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MD] != null) {
        const memberEntries = se_MetricData(input[_MD], context);
        if (input[_MD]?.length === 0) {
            entries.MetricData = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EMD] != null) {
        const memberEntries = se_EntityMetricDataList(input[_EMD], context);
        if (input[_EMD]?.length === 0) {
            entries.EntityMetricData = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EntityMetricData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SEV] != null) {
        entries[_SEV] = input[_SEV];
    }
    return entries;
};
const se_PutMetricStreamInput = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_IF] != null) {
        const memberEntries = se_MetricStreamFilters(input[_IF], context);
        if (input[_IF]?.length === 0) {
            entries.IncludeFilters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IncludeFilters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EF] != null) {
        const memberEntries = se_MetricStreamFilters(input[_EF], context);
        if (input[_EF]?.length === 0) {
            entries.ExcludeFilters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludeFilters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_FA] != null) {
        entries[_FA] = input[_FA];
    }
    if (input[_RAo] != null) {
        entries[_RAo] = input[_RAo];
    }
    if (input[_OF] != null) {
        entries[_OF] = input[_OF];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SC] != null) {
        const memberEntries = se_MetricStreamStatisticsConfigurations(input[_SC], context);
        if (input[_SC]?.length === 0) {
            entries.StatisticsConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StatisticsConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ILAM] != null) {
        entries[_ILAM] = input[_ILAM];
    }
    return entries;
};
const se_Range = (input, context) => {
    const entries = {};
    if (input[_ST] != null) {
        entries[_ST] = __serializeDateTime(input[_ST]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    return entries;
};
const se_ResourceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetAlarmStateInput = (input, context) => {
    const entries = {};
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_SV] != null) {
        entries[_SV] = input[_SV];
    }
    if (input[_SRt] != null) {
        entries[_SRt] = input[_SRt];
    }
    if (input[_SRD] != null) {
        entries[_SRD] = input[_SRD];
    }
    return entries;
};
const se_SingleMetricAnomalyDetector = (input, context) => {
    const entries = {};
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    return entries;
};
const se_StartMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input[_Nam] != null) {
        const memberEntries = se_MetricStreamNames(input[_Nam], context);
        if (input[_Nam]?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Statistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;