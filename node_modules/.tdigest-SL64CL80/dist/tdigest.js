(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals
        this.tdigest = factory();
    }
}(function () {
    var global = this, define;
    function _require(id) {
        var module = _require.cache[id];
        if (!module) {
            var exports = {};
            module = _require.cache[id] = {
                id: id,
                exports: exports
            };
            _require.modules[id].call(exports, module, exports);
        }
        return module.exports;
    }
    _require.cache = [];
    _require.modules = [
        function (module, exports) {
            module.exports = {
                RBTree: _require(2),
                BinTree: _require(1)
            };
        },
        function (module, exports) {
            var TreeBase = _require(3);
            function Node(data) {
                this.data = data;
                this.left = null;
                this.right = null;
            }
            Node.prototype.get_child = function (dir) {
                return dir ? this.right : this.left;
            };
            Node.prototype.set_child = function (dir, val) {
                if (dir) {
                    this.right = val;
                } else {
                    this.left = val;
                }
            };
            function BinTree(comparator) {
                this._root = null;
                this._comparator = comparator;
                this.size = 0;
            }
            BinTree.prototype = new TreeBase();    // returns true if inserted, false if duplicate
            // returns true if inserted, false if duplicate
            BinTree.prototype.insert = function (data) {
                if (this._root === null) {
                    // empty tree
                    this._root = new Node(data);
                    this.size++;
                    return true;
                }
                var dir = 0;    // setup
                // setup
                var p = null;    // parent
                // parent
                var node = this._root;    // search down
                // search down
                while (true) {
                    if (node === null) {
                        // insert new node at the bottom
                        node = new Node(data);
                        p.set_child(dir, node);
                        ret = true;
                        this.size++;
                        return true;
                    }    // stop if found
                    // stop if found
                    if (this._comparator(node.data, data) === 0) {
                        return false;
                    }
                    dir = this._comparator(node.data, data) < 0;    // update helpers
                    // update helpers
                    p = node;
                    node = node.get_child(dir);
                }
            };    // returns true if removed, false if not found
            // returns true if removed, false if not found
            BinTree.prototype.remove = function (data) {
                if (this._root === null) {
                    return false;
                }
                var head = new Node(undefined);    // fake tree root
                // fake tree root
                var node = head;
                node.right = this._root;
                var p = null;    // parent
                // parent
                var found = null;    // found item
                // found item
                var dir = 1;
                while (node.get_child(dir) !== null) {
                    p = node;
                    node = node.get_child(dir);
                    var cmp = this._comparator(data, node.data);
                    dir = cmp > 0;
                    if (cmp === 0) {
                        found = node;
                    }
                }
                if (found !== null) {
                    found.data = node.data;
                    p.set_child(p.right === node, node.get_child(node.left === null));
                    this._root = head.right;
                    this.size--;
                    return true;
                } else {
                    return false;
                }
            };
            module.exports = BinTree;
        },
        function (module, exports) {
            var TreeBase = _require(3);
            function Node(data) {
                this.data = data;
                this.left = null;
                this.right = null;
                this.red = true;
            }
            Node.prototype.get_child = function (dir) {
                return dir ? this.right : this.left;
            };
            Node.prototype.set_child = function (dir, val) {
                if (dir) {
                    this.right = val;
                } else {
                    this.left = val;
                }
            };
            function RBTree(comparator) {
                this._root = null;
                this._comparator = comparator;
                this.size = 0;
            }
            RBTree.prototype = new TreeBase();    // returns true if inserted, false if duplicate
            // returns true if inserted, false if duplicate
            RBTree.prototype.insert = function (data) {
                var ret = false;
                if (this._root === null) {
                    // empty tree
                    this._root = new Node(data);
                    ret = true;
                    this.size++;
                } else {
                    var head = new Node(undefined);    // fake tree root
                    // fake tree root
                    var dir = 0;
                    var last = 0;    // setup
                    // setup
                    var gp = null;    // grandparent
                    // grandparent
                    var ggp = head;    // grand-grand-parent
                    // grand-grand-parent
                    var p = null;    // parent
                    // parent
                    var node = this._root;
                    ggp.right = this._root;    // search down
                    // search down
                    while (true) {
                        if (node === null) {
                            // insert new node at the bottom
                            node = new Node(data);
                            p.set_child(dir, node);
                            ret = true;
                            this.size++;
                        } else if (is_red(node.left) && is_red(node.right)) {
                            // color flip
                            node.red = true;
                            node.left.red = false;
                            node.right.red = false;
                        }    // fix red violation
                        // fix red violation
                        if (is_red(node) && is_red(p)) {
                            var dir2 = ggp.right === gp;
                            if (node === p.get_child(last)) {
                                ggp.set_child(dir2, single_rotate(gp, !last));
                            } else {
                                ggp.set_child(dir2, double_rotate(gp, !last));
                            }
                        }
                        var cmp = this._comparator(node.data, data);    // stop if found
                        // stop if found
                        if (cmp === 0) {
                            break;
                        }
                        last = dir;
                        dir = cmp < 0;    // update helpers
                        // update helpers
                        if (gp !== null) {
                            ggp = gp;
                        }
                        gp = p;
                        p = node;
                        node = node.get_child(dir);
                    }    // update root
                    // update root
                    this._root = head.right;
                }    // make root black
                // make root black
                this._root.red = false;
                return ret;
            };    // returns true if removed, false if not found
            // returns true if removed, false if not found
            RBTree.prototype.remove = function (data) {
                if (this._root === null) {
                    return false;
                }
                var head = new Node(undefined);    // fake tree root
                // fake tree root
                var node = head;
                node.right = this._root;
                var p = null;    // parent
                // parent
                var gp = null;    // grand parent
                // grand parent
                var found = null;    // found item
                // found item
                var dir = 1;
                while (node.get_child(dir) !== null) {
                    var last = dir;    // update helpers
                    // update helpers
                    gp = p;
                    p = node;
                    node = node.get_child(dir);
                    var cmp = this._comparator(data, node.data);
                    dir = cmp > 0;    // save found node
                    // save found node
                    if (cmp === 0) {
                        found = node;
                    }    // push the red node down
                    // push the red node down
                    if (!is_red(node) && !is_red(node.get_child(dir))) {
                        if (is_red(node.get_child(!dir))) {
                            var sr = single_rotate(node, dir);
                            p.set_child(last, sr);
                            p = sr;
                        } else if (!is_red(node.get_child(!dir))) {
                            var sibling = p.get_child(!last);
                            if (sibling !== null) {
                                if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                                    // color flip
                                    p.red = false;
                                    sibling.red = true;
                                    node.red = true;
                                } else {
                                    var dir2 = gp.right === p;
                                    if (is_red(sibling.get_child(last))) {
               