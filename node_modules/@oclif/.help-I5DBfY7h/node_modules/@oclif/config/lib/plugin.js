"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@oclif/errors");
const path = require("path");
const util_1 = require("util");
const command_1 = require("./command");
const debug_1 = require("./debug");
const ts_node_1 = require("./ts-node");
const util_2 = require("./util");
const ROOT_INDEX_CMD_ID = '';
const _pjson = require('../package.json');
const hasManifest = function (p) {
    try {
        require(p);
        return true;
    }
    catch (_a) {
        return false;
    }
};
function topicsToArray(input, base) {
    if (!input)
        return [];
    base = base ? `${base}:` : '';
    if (Array.isArray(input)) {
        return input.concat(util_2.flatMap(input, t => topicsToArray(t.subtopics, `${base}${t.name}`)));
    }
    return util_2.flatMap(Object.keys(input), k => {
        input[k].name = k;
        return [Object.assign(Object.assign({}, input[k]), { name: `${base}${k}` })].concat(topicsToArray(input[k].subtopics, `${base}${input[k].name}`));
    });
}
// essentially just "cd .."
function* up(from) {
    while (path.dirname(from) !== from) {
        yield from;
        from = path.dirname(from);
    }
    yield from;
}
async function findSourcesRoot(root) {
    for (const next of up(root)) {
        const cur = path.join(next, 'package.json');
        // eslint-disable-next-line no-await-in-loop
        if (await util_2.exists(cur))
            return path.dirname(cur);
    }
}
/**
 * @returns string
 * @param name string
 * @param root string
 * find package root
 * for packages installed into node_modules this will go up directories until
 * it finds a node_modules directory with the plugin installed into it
 *
 * This is needed because some oclif plugins do not declare the `main` field in their package.json
 * https://github.com/oclif/config/pull/289#issuecomment-983904051
 */
async function findRootLegacy(name, root) {
    for (const next of up(root)) {
        let cur;
        if (name) {
            cur = path.join(next, 'node_modules', name, 'package.json');
            // eslint-disable-next-line no-await-in-loop
            if (await util_2.exists(cur))
                return path.dirname(cur);
            try {
                // eslint-disable-next-line no-await-in-loop
                const pkg = await util_2.loadJSON(path.join(next, 'package.json'));
                if (pkg.name === name)
                    return next;
            }
            catch (_a) { }
        }
        else {
            cur = path.join(next, 'package.json');
            // eslint-disable-next-line no-await-in-loop
            if (await util_2.exists(cur))
                return path.dirname(cur);
        }
    }
}
async function findRoot(name, root) {
    if (name) {
        let pkgPath;
        try {
            pkgPath = util_2.resolvePackage(name, { paths: [root] });
        }
        catch (error) { }
        return pkgPath ? findSourcesRoot(path.dirname(pkgPath)) : findRootLegacy(name, root);
    }
    return findSourcesRoot(root);
}
class Plugin {
    // eslint-disable-next-line no-useless-constructor
    constructor(options) {
        this.options = options;
        // static loadedPlugins: {[name: string]: Plugin} = {}
        this._base = `${_pjson.name}@${_pjson.version}`;
        this.valid = false;
        this.alreadyLoaded = false;
        this.children = [];
        // eslint-disable-next-line new-cap
        this._debug = debug_1.default();
        this.warned = false;
    }
    async load() {
        this.type = this.options.type || 'core';
        this.tag = this.options.tag;
        const root = await findRoot(this.options.name, this.options.root);
        if (!root)
            throw new Error(`could not find package.json with ${util_1.inspect(this.options)}`);
        this.root = root;
        this._debug('reading %s plugin %s', this.type, root);
        this.pjson = await util_2.loadJSON(path.join(root, 'package.json'));
        this.name = this.pjson.name;
        const pjsonPath = path.join(root, 'package.json');
        if (!this.name)
            throw new Error(`no name in ${pjsonPath}`);
        const isProd = hasManifest(path.join(root, 'oclif.manifest.json'));
        if (!isProd && !this.pjson.files)
            this.warn(`files attribute must be specified in ${pjsonPath}`);
        // eslint-disable-next-line new-cap
        this._debug = debug_1.default(this.name);
        this.version = this.pjson.version;
        if (this.pjson.oclif) {
            this.valid = true;
        }
        else {
            this.pjson.oclif = this.pjson['cli-engine'] || {};
        }
        this.hooks = util_2.mapValues(this.pjson.oclif.hooks || {}, i => Array.isArray(i) ? i : [i]);
        this.manifest = await this._manifest(Boolean(this.options.ignoreManifest), Boolean(this.options.errorOnManifestCreate));
        this.commands = Object.entries(this.manifest.commands)
            .map(([id, c]) => (Object.assign(Object.assign({}, c), { load: () => this.findCommand(id, { must: true }) })));
        this.commands.sort((a, b) => {
            if (