// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
/**
 * returns an async iterator that iterates over results. It also has a `byPage`
 * method that returns pages of items at once.
 *
 * @param pagedResult - an object that specifies how to get pages.
 * @returns a paged async iterator that iterates over results.
 */
export function getPagedAsyncIterator(pagedResult) {
    var _a;
    const iter = getItemAsyncIterator(pagedResult);
    return {
        next() {
            return iter.next();
        },
        [Symbol.asyncIterator]() {
            return this;
        },
        byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : ((settings) => {
            const { continuationToken, maxPageSize } = settings !== null && settings !== void 0 ? settings : {};
            return getPageAsyncIterator(pagedResult, {
                pageLink: continuationToken,
                maxPageSize,
            });
        }),
    };
}
function getItemAsyncIterator(pagedResult) {
    return __asyncGenerator(this, arguments, function* getItemAsyncIterator_1() {
        var _a, e_1, _b, _c, _d, e_2, _e, _f;
        const pages = getPageAsyncIterator(pagedResult);
        const firstVal = yield __await(pages.next());
        // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is
        if (!Array.isArray(firstVal.value)) {
            // can extract elements from this page
            const { toElements } = pagedResult;
            if (toElements) {
                yield __await(yield* __asyncDelegator(__asyncValues(toElements(firstVal.value))));
                try {
                    for (var _g = true, pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = yield __await(pages_1.next()), _a = pages_1_1.done, !_a; _g = true) {
                        _c = pages_1_1.value;
                        _g = false;
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(toElements(page))));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_g && !_a && (_b = pages_1.return)) yield __await(_b.call(pages_1));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else