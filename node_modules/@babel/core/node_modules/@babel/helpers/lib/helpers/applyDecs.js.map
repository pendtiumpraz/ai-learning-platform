{"version":3,"names":["_setFunctionName","require","_toPropertyKey","old_createMetadataMethodsForProperty","metadataMap","kind","property","decoratorFinishedRef","getMetadata","key","old_assertNotFinished","old_assertMetadataKey","metadataForKey","pub","public","priv","private","get","Object","hasOwnProperty","call","constructor","setMetadata","value","Map","set","old_convertMetadataMapToFinal","obj","parentMetadataMap","Symbol","metadata","for","metadataKeys","getOwnPropertySymbols","length","i","metaForKey","parentMetaForKey","parentPub","setPrototypeOf","privArr","Array","from","values","parentPriv","concat","old_createAddInitializerMethod","initializers","addInitializer","initializer","old_assertCallable","push","old_memberDec","dec","name","desc","isStatic","isPrivate","kindStr","ctx","toPropertyKey","v","metadataKind","metadataName","access","assign","fnName","Error","TypeError","fn","hint","old_assertValidReturnValue","type","undefined","init","old_getInit","console","warn","old_applyMemberDec","ret","base","decInfo","decs","prefix","setFunctionName","getOwnPropertyDescriptor","newValue","newInit","instance","ownInitializers","originalInitializer","args","defineProperty","old_applyMemberDecs","Class","protoMetadataMap","staticMetadataMap","decInfos","protoInitializers","staticInitializers","existingProtoNonFields","existingStaticNonFields","isArray","prototype","existingNonFields","existingKind","old_pushInitializers","old_applyClassDecs","targetClass","classDecs","newClass","nextNewClass","applyDecs","memberDecs"],"sources":["../../src/helpers/applyDecs.js"],"sourcesContent":["/* @minVersion 7.17.8 */\n/* @onlyBabel7 */\n\nimport setFunctionName from \"setFunctionName\";\nimport toPropertyKey from \"toPropertyKey\";\n/**\n * NOTE: This is an old version of the helper, used for 2021-12 decorators.\n * Updates should be done in applyDecs2203R.js.\n */\n\n/**\n  Enums are used in this file, but not assigned to vars to avoid non-hoistable values\n\n  CONSTRUCTOR = 0;\n  PUBLIC = 1;\n  PRIVATE = 2;\n\n  FIELD = 0;\n  ACCESSOR = 1;\n  METHOD = 2;\n  GETTER = 3;\n  SETTER = 4;\n\n  STATIC = 5;\n\n  CLASS = 10; // only used in assertValidReturnValue\n*/\n\nfunction old_createMetadataMethodsForProperty(\n  metadataMap,\n  kind,\n  property,\n  decoratorFinishedRef,\n) {\n  return {\n    getMetadata: function (key) {\n      old_assertNotFinished(decoratorFinishedRef, \"getMetadata\");\n      old_assertMetadataKey(key);\n\n      var metadataForKey = metadataMap[key];\n\n      if (metadataForKey === void 0) return void 0;\n\n      if (kind === 1 /* PUBLIC */) {\n        var pub = metadataForKey.public;\n        if (pub !== void 0) {\n          return pub[property];\n        }\n      } else if (kind === 2 /* PRIVATE */) {\n        var priv = metadataForKey.private;\n        if (priv !== void 0) {\n          return priv.get(property);\n        }\n      } else if (Object.hasOwnProperty.call(metadataForKey, \"constructor\")) {\n        return metadataForKey.constructor;\n      }\n    },\n    setMetadata: function (key, value) {\n      old_assertNotFinished(decoratorFinishedRef, \"setMetadata\");\n      old_assertMetadataKey(key);\n\n      var metadataForKey = metadataMap[key];\n\n      if (metadataForKey === void 0) {\n        metadataForKey = metadataMap[key] = {};\n      }\n\n      if (kind === 1 /* PUBLIC */) {\n        var pub = metadataForKey.public;\n\n        if (pub === void 0) {\n          pub = metadataForKey.public = {};\n        }\n\n        pub[property] = value;\n      } else if (kind === 2 /* PRIVATE */) {\n        var priv = metadataForKey.priv;\n\n        if (priv === void 0) {\n          priv = metadataForKey.private = new Map();\n        }\n\n        priv.set(property, value);\n      } else {\n        metadataForKey.constructor = value;\n      }\n    },\n  };\n}\n\nfunction old_convertMetadataMapToFinal(obj, metadataMap) {\n  var parentMetadataMap = obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")];\n  var metadataKeys = Object.getOwnPropertySymbols(metadataMap);\n\n  if (metadataKeys.length === 0) return;\n\n  for (var i = 0; i < metadataKeys.length; i++) {\n    var key = metadataKeys[i];\n    var metaForKey = metadataMap[key];\n    var parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null;\n\n    var pub = metaForKey.public;\n    var parentPub = parentMetaForKey ? parentMetaForKey.public : null;\n\n    if (pub && parentPub) {\n      Object.setPrototypeOf(pub, parentPub);\n    }\n\n    var priv = metaForKey.private;\n\n    if (priv) {\n      var privArr = Array.from(priv.values());\n      var parentPriv = parentMetaForKey ? parentMetaForKey.private : null;\n\n      if (parentPriv) {\n        privArr = privArr.concat(parentPriv);\n      }\n\n      metaForKey.private = privArr;\n    }\n\n    if (parentMetaForKey) {\n      Object.setPrototypeOf(metaForKey, parentMetaForKey);\n    }\n  }\n\n  if (parentMetadataMap) {\n    Object.setPrototypeOf(metadataMap, parentMetadataMap);\n  }\n\n  obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")] = metadataMap;\n}\n\nfunction old_createAddInitializerMethod(initializers, decoratorFinishedRef) {\n  return function addInitializer(initializer) {\n    old_assertNotFinished(decoratorFinishedRef, \"addInitializer\");\n    old_assertCallable(initializer, \"An initializer\");\n    initializers.push(initializer);\n  };\n}\n\nfunction old_memberDec(\n  dec,\n  name,\n  desc,\n  metadataMap,\n  initializers,\n  kind,\n  isStatic,\n  isPrivate,\n  value,\n) {\n  var kindStr;\n\n  switch (kind) {\n    case 1 /* ACCESSOR */:\n      kindStr = \"accessor\";\n      break;\n    case 2 /* METHOD */:\n      kindStr = \"method\";\n      break;\n    case 3 /* GETTER */:\n      kindStr = \"getter\";\n      break;\n    case 4 /* SETTER */:\n      kindStr = \"setter\";\n      break;\n    default:\n      kindStr = \"field\";\n  }\n\n  var ctx = {\n    kind: kindStr,\n    name: isPrivate ? \"#\" + name : toPropertyKey(name),\n    isStatic: isStatic,\n    isPrivate: isPrivate,\n  };\n\n  var decoratorFinishedRef = { v: false };\n\n  if (kind !== 0 /* FIELD */) {\n    ctx.addInitializer = old_createAddInitializerMethod(\n      initializers,\n      decoratorFinishedRef,\n    );\n  }\n\n  var metadataKind, metadataName;\n\n  if (isPrivate) {\n    metadataKind = 2 /* PRIVATE */;\n    metadataName = Symbol(name);\n\n    var access = {};\n\n    if (kind === 0 /* FIELD */) {\n      access.get = desc.get;\n      access.set = desc.set;\n    } else if (kind === 2 /* METHOD */) {\n      access.get = function () {\n        return desc.value;\n      };\n    } else {\n      // replace with values that will go through the final getter and setter\n      if (kind === 1 /* ACCESSOR */ || kind === 3 /* GETTER */) {\n        access.get = function () {\n          return desc.get.call(this);\n        };\n      }\n\n      if (kind === 1 /* ACCESSOR */ || kind === 4 /* SETTER */) {\n        access.set = function (v) {\n          desc.set.call(this, v);\n        };\n      }\n    }\n\n    ctx.access = access;\n  } else {\n    metadataKind = 1 /* PUBLIC */;\n    metadataName = name;\n  }\n\n  try {\n    return dec(\n      value,\n      Object.assign(\n        ctx,\n        old_createMetadataMethodsForProperty(\n          metadataMap,\n          metadataKind,\n          metadataName,\n          decoratorFinishedRef,\n        ),\n      ),\n    );\n  } finally {\n    decoratorFinishedRef.v = true;\n  }\n}\n\nfunction old_assertNotFinished(decoratorFinishedRef, fnName) {\n  if (decoratorFinishedRef.v) {\n    throw new Error(\n      \"attempted to call \" + fnName + \" after decoration was finished\",\n    );\n  }\n}\n\nfunction old_assertMetadataKey(key) {\n  if (typeof key !== \"symbol\") {\n    throw new TypeError(\"Metadata keys must be symbols, received: \" + key);\n  }\n}\n\nfunction old_assertCallable(fn, hint) {\n  if (typeof fn !== \"function\") {\n    throw new TypeError(hint + \" must be a function\");\n  }\n}\n\nfunction old_assertValidReturnValue(kind, value) {\n  var type = typeof value;\n\n  if (kind === 1 /* ACCESSOR */) {\n    if (type !== \"object\" || value === null) {\n      throw new TypeError(\n        \"accessor decorators must return an object with get, set, or init properties or void 0\",\n      );\n    }\n    if (value.get !== undefined) {\n      old_assertCallable(value.get, \"accessor.get\");\n    }\n    if (value.set !== undefined) {\n      old_assertCallable(value.set, \"accessor.set\");\n    }\n    if (value.init !== undefined) {\n      old_assertCallable(value.init, \"accessor.init\");\n    }\n    if (value.initializer !== undefined) {\n      old_assertCallable(value.initializer, \"accessor.ini