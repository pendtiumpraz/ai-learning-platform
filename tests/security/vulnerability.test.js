/**
 * Vulnerability Assessment Tests
 * Automated scanning for common web vulnerabilities
 */

const request = require('supertest');
const { app } = require('../../src/app');

describe('Vulnerability Assessment', () => {
  describe('OWASP Top 10 Vulnerabilities', () => {
    describe('A01: Broken Access Control', () => {
      test('should prevent horizontal privilege escalation', async () => {
        // User A's data
        const userAToken = 'user-a-token';
        const userBId = 'user-b-id';

        // Try to access user B's data with user A's token
        const response = await request(app)
          .get(`/api/admin/users/${userBId}`)
          .set('Authorization', `Bearer ${userAToken}`)
          .expect(403);

        expect(response.body).toHaveProperty('error');
        expect(response.body.error).toMatch(/forbidden|unauthorized/i);
      });

      test('should enforce role-based access control', async () => {
        const userToken = 'regular-user-token';

        const adminEndpoints = [
          '/api/admin/users',
          '/api/admin/analytics',
          '/api/admin/system-health',
          '/api/admin/api-keys',
        ];

        for (const endpoint of adminEndpoints) {
          await request(app)
            .get(endpoint)
            .set('Authorization', `Bearer ${userToken}`)
            .expect(403);
        }
      });
    });

    describe('A02: Cryptographic Failures', () => {
      test('should use HTTPS for sensitive operations', async () => {
        // This test would run against the actual deployment
        // For local testing, we verify that HTTPS redirect is configured
        const response = await request(app)
          .post('/api/auth/login')
          .send({
            email: 'test@example.com',
            password: 'password123'
          })
          .set('X-Forwarded-Proto', 'http');

        // In production, should redirect to HTTPS
        if (process.env.NODE_ENV === 'production') {
          expect(response.status).toBe(301);
          expect(response.headers.location).toMatch(/^https:\/\//);
        }
      });

      test('should use strong encryption for sensitive data', async () => {
        const encryption = require('../../src/utils/encryption');

        const testData = 'sensitive-user-data-123';
        const encrypted = encryption.encrypt(testData);
        const decrypted = encryption.decrypt(encrypted);

        expect(encrypted).not.toBe(testData);
        expect(decrypted).toBe(testData);
        expect(encrypted.length).toBeGreaterThan(testData.length);
      });
    });

    describe('A03: Injection', () => {
      test('should prevent NoSQL injection', async () => {
        const nosqlPayloads = [
          { '$ne': null },
          { '$where': 'this.password == this.password' },
          { '$gt': '' },
          { '$regex': '.*' },
        ];

        for (const payload of nosqlPayloads) {
          const response = await request(app)
            .post('/api/user/search')
            .send({ query: payload })
            .set('Authorization', 'Bearer valid-token')
            .expect(400);

          expect(response.body).toHaveProperty('error');
        }
      });

      test('should prevent command injection', async () => {
        const commandPayloads = [
          '; ls -la',
          '| whoami',
          '&& cat /etc/passwd',
          '`id`',
          '$(id)',
        ];

        for (const payload of commandPayloads) {
          const response = await request(app)
            .post('/api/tools/execute')
            .send({ command: payload })
            .set('Authorization', 'Bearer valid-token')
            .expect(400);

          expect(response.body).toHaveProperty('error');
        }
      });
    });

    describe('A05: Security Misconfiguration', () => {
      test('should not expose stack traces in production', async () => {
        // Force an error
        const response = await request(app)
          .get('/api/error-test')
          .expect(500);

        const errorString = JSON.stringify(response.body);

        if (process.env.NODE_ENV === 'production') {
          expect(errorString).not.toMatch(/stack trace|Error:|at /);
          expect(errorString).not.toMatch(/\.js:\d+:\d+/);
        }
      });

      test('should not expose server information', async () => {
        const response = await request(app)
          .get('/')
          .expect(200);

        expect(response.headers).not.toHaveProperty('x-powered-by');
        expect(response.headers).not.toHaveProperty('server');
      });

      test('should implement proper security headers', async () => {
        const response = await request(app)
          .get('/api/health')
          .expect(200);

        // Security headers
        expect(response.headers['x-frame-options']).toMatch(/DENY|SAMEORIGIN/);
        expect(response.headers['x-content-type-options']).toBe('nosniff');
        expect(response.headers['referrer-policy']).toMatch(/strict-origin-when-cross-origin|same-origin|no-referrer/);

        // In production
        if (process.env.NODE_ENV === 'production') {
          expect(response.headers['strict-transport-security']).toMatch(/max-age=\d+/);
          expect(response.headers['content-security-policy']).toBeDefined();
        }
      });
    });

    describe('A07: Identification and Authentication Failures', () => {
      test('should enforce strong password requirements', async () => {
        const weakPasswords = [
          '123456',
          'password',
          'qwerty',
          'abc123',
          '111111',
          'letmein',
        ];

        for (const password of weakPasswords) {
          const response = await request(app)
            .post('/api/auth/register')
            .send({
              email: `test${Math.random()}@example.com`,
              password: password,
              name: 'Test User'
            })
            .expect(400);

          expect(response.body.error).toMatch(/weak|strong|required/i);
        }
      });

      test('should implement secure session management', async () => {
        const loginResponse = await request(app)
          .post('/api/auth/login')
          .send({
            email: 'session@test.com',
            password: 'SecurePass123!'
          })
          .expect(200);

        const token = loginResponse.body.token;

        // Session should be valid
        await request(app)
          .get('/api/user/profile')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);

        // Session should expire after logout
        await request(app)
          .post('/api/auth/logout')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);

        await request(app)
          .get('/api/user/profile')
          .set('Authorization', `Bearer ${token}`)
          .expect(401);
      });

      test('should prevent credential stuffing', async () => {
        const commonCredentials = [
          { email: 'admin@example.com', password: 'admin123' },
          { email: 'user@example.com', password: 'password123' },
          { email: 'test@example.com', password: '123456' },
        ];

        // Simulate credential stuffing attack
        const promises = commonCredentials.map(creds =>
          request(app)
            .post('/api/auth/login')
            .send(creds)
        );

        const responses = await Promise.all(promises);

        // Should implement rate limiting or account lockout
        const rateLimited = responses.filter(res => res.status === 429);
        expect(rateLimited.length).toBeGreaterThan(0);
      });
    });

    describe('A08: Software and Data Integrity Failures', () => {
      test('should validate API response integrity', async () => {
        const response = await request(app)
          .get('/api/user/progress')
          .set('Authorization', 'Bearer valid-token')
          .expect(200);

        // Validate response structure
        expect(response.body).toHaveProperty('progress');
        expect(Array.isArray(response.body.progress)).toBe(true);

        // Each progress item should have required fields
        if (response.body.progress.length > 0) {
          const progressItem = response.body.progress[0];
          expect(progressItem).toHaveProperty('subject');
          expect(progressItem).toHaveProperty('score');
          expect(progressItem).toHaveProperty('updatedAt');
        }
      });

      test('should prevent data tampering in requests', async () => {
        // Try to submit tampered progress data
        const tamperedData = {
          subject: 'mathematics',
          progress: 150, // Exceeds maximum
          score: 999, // Impossible score
          timestamp: Date.now() - 86400000, // Backdated
        };

        const response = await request(app)
          .post('/api/user/progress')
          .set('Authorization', 'Bearer valid-token')
          .send(tamperedData)
          .expect(400);

        expect(response.body.error).toMatch(/invalid|exceeds|range/i);
      });
    });

    describe('A09: Security Logging and Monitoring Failures', () => {
      test('should log security events', async () => {
        // This would test that security events are properly logged
        // In a real implementation, you'd check log files or monitoring systems

        // Simulate failed login attempts
        await request(app)
          .post('/api/auth/login')
          .send({
            email: 'nonexistent@example.com',
            password: 'wrongpassword'
          })
          .expect(401);

        // Verify logging (this would be implementation-specific)
        // For testing purposes, we ensure the error is properly handled
        const response = await request(app)
          .post('/api/auth/login')
          .send({
            email: 'nonexistent@example.com',
            password: 'wrongpassword'
          })
          .expect(401);

        expect(response.body).toHaveProperty('error');
      });

      test('should implement request rate limiting monitoring', async () => {
        // Make rapid requests to trigger rate limiting
        const promises = Array(20).fill().map(() =>
          request(app)
            .post('/api/auth/login')
            .send({
              email: 'ratelimit@example.com',
              password: 'wrongpassword'
            })
        );

        const responses = await Promise.all(promises);

        const rateLimited = responses.filter(res => res.status === 429);
        expect(rateLimited.length).toBeGreaterThan(0);

        // Check for rate limit headers
        const rateLimitResponse = responses.find(res => res.status === 429);
        if (rateLimitResponse) {
          expect(rateLimitResponse.headers).toHaveProperty('retry-after');
          expect(rateLimitResponse.headers).toHaveProperty('x-ratelimit-remaining');
        }
      });
    });

    describe('A10: Server-Side Request Forgery (SSRF)', () => {
      test('should prevent SSRF in AI API calls', async () => {
        const ssrfPayloads = [
          'http://localhost:8080/admin',
          'http://127.0.0.1:22',
          'file:///etc/passwd',
          'ftp://internal-server/files',
          'http://169.254.169.254/latest/meta-data/', // AWS metadata
        ];

        for (const payload of ssrfPayloads) {
          const response = await request(app)
            .post('/api/ask')
            .send({
              question: `Call this API: ${payload}`,
              subject: 'programming',
              level: 'advanced'
            })
            .expect(400);

          expect(response.body).toHaveProperty('error');
          expect(response.body.error).toMatch(/invalid|forbidden|blocked/i);
        }
      });

      test('should validate external URLs', async () => {
        const maliciousUrls = [
          'javascript:alert("xss")',
          'data:text/html,<script>alert("xss")</script>',
          'vbscript:msgbox("xss")',
        ];

        for (const url of maliciousUrls) {
          const response = await request(app)
            .post('/api/tools/fetch-url')
            .send({ url })
            .set('Authorization', 'Bearer valid-token')
            .expect(400);

          expect(response.body).toHaveProperty('error');
        }
      });
    });
  });

  describe('Additional Security Tests', () => {
    test('should handle concurrent requests safely', async () => {
      const userId = 'concurrent-test-user';
      const token = 'valid-concurrent-token';

      // Make concurrent requests to modify same data
      const promises = Array(10).fill().map((_, i) =>
        request(app)
          .post('/api/user/progress')
          .set('Authorization', `Bearer ${token}`)
          .send({
            subject: 'mathematics',
            progress: i * 10
          })
      );

      const responses = await Promise.all(promises);

      // Should handle gracefully without data corruption
      const successfulResponses = responses.filter(res => res.status === 201);
      expect(successfulResponses.length).toBeGreaterThan(0);

      // Verify data integrity
      const finalResponse = await request(app)
        .get('/api/user/progress')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      expect(finalResponse.body).toHaveProperty('progress');
    });

    test('should implement proper error rate limiting', async () => {
      // Generate errors rapidly
      const promises = Array(50).fill().map(() =>
        request(app)
          .get('/api/nonexistent-' + Math.random())
      );

      const responses = await Promise.all(promises);

      // Should implement error rate limiting
      const rateLimited = responses.filter(res => res.status === 429);
      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });
});